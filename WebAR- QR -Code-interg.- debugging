# WebAR QR Code Integration - Complete Implementation
# QEIT Principle: Resonant Interactive Feedback System

from flask import Flask, request, jsonify, render_template_string
from flask_cors import CORS
from datetime import datetime, timedelta
import json
import os
import hashlib
import time
from collections import defaultdict
import logging

# Initialize Flask app
app = Flask(__name__)
CORS(app)  # Enable CORS for WebAR
app.config['SECRET_KEY'] = 'your-secret-key-here'

# Configuration
METRICS_FILE = "resonant_feedback_metrics.json"
RATE_LIMIT_FILE = "rate_limits.json"
MAX_REQUESTS_PER_MINUTE = 60
SUPPORTED_BROWSERS = {
    'chrome': {'min_version': 67, 'ar_support': True},
    'safari': {'min_version': 11, 'ar_support': True},
    'firefox': {'min_version': 60, 'ar_support': False},
    'edge': {'min_version': 79, 'ar_support': True}
}

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ResonantFeedbackSystem:
    """QEIT Principle: Resonant Interactive Feedback implementation"""
    
    def __init__(self):
        self.metrics = []
        self.recommendations = []
        self.performance_thresholds = {
            'load_time_critical': 5000,  # 5 seconds
            'load_time_good': 3000,      # 3 seconds
            'ar_success_rate_min': 0.8   # 80% success rate
        }
    
    def save_metric(self, metric: dict):
        """Save metric with validation and security checks"""
        try:
            # Validate required fields
            required_fields = ['device', 'browser', 'ar_loaded', 'load_time_ms']
            for field in required_fields:
                if field not in metric:
                    raise ValueError(f"Missing required field: {field}")
            
            # Data sanitization
            sanitized_metric = {
                "timestamp": datetime.now().isoformat(),
                "device": str(metric.get("device", "unknown"))[:50],
                "browser": str(metric.get("browser", "unknown"))[:50],
                "ar_loaded": bool(metric.get("ar_loaded", False)),
                "fallback_used": bool(metric.get("fallback_used", False)),
                "load_time_ms": max(0, int(metric.get("load_time_ms", 0))),
                "user_agent": str(metric.get("user_agent", ""))[:200],
                "screen_resolution": str(metric.get("screen_resolution", ""))[:20],
                "ar_session_duration": max(0, int(metric.get("ar_session_duration", 0))),
                "errors": str(metric.get("errors", ""))[:500]
            }
            
            # Load existing metrics
            if os.path.exists(METRICS_FILE):
                with open(METRICS_FILE, "r", encoding='utf-8') as f:
                    data = json.load(f)
            else:
                data = []
            
            data.append(sanitized_metric)
            
            # Keep only last 10000 entries to prevent file bloat
            if len(data) > 10000:
                data = data[-10000:]
            
            # Save metrics
            with open(METRICS_FILE, "w", encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            # Trigger resonant analysis
            self.analyze_and_recommend(data)
            
            logger.info(f"Metric saved: {sanitized_metric['device']}, AR loaded: {sanitized_metric['ar_loaded']}")
            return True
            
        except Exception as e:
            logger.error(f"Error saving metric: {e}")
            return False
    
    def analyze_and_recommend(self, metrics_data):
        """QEIT Resonant Analysis - Generate recommendations from usage patterns"""
        if len(metrics_data) < 10:  # Need minimum data for analysis
            return
        
        # Analyze recent metrics (last 100 entries)
        recent_metrics = metrics_data[-100:]
        
        # Calculate performance metrics
        ar_success_rate = sum(1 for m in recent_metrics if m['ar_loaded']) / len(recent_metrics)
        avg_load_time = sum(m['load_time_ms'] for m in recent_metrics) / len(recent_metrics)
        fallback_usage = sum(1 for m in recent_metrics if m['fallback_used']) / len(recent_metrics)
        
        # Device/browser analysis
        device_stats = defaultdict(list)
        for metric in recent_metrics:
            key = f"{metric['device']}_{metric['browser']}"
            device_stats[key].append(metric)
        
        recommendations = []
        
        # Performance recommendations
        if avg_load_time > self.performance_thresholds['load_time_critical']:
            recommendations.append({
                'type': 'performance',
                'priority': 'critical',
                'message': f'Average load time ({avg_load_time:.0f}ms) exceeds critical threshold',
                'action': 'Optimize AR assets, implement progressive loading'
            })
        elif avg_load_time > self.performance_thresholds['load_time_good']:
            recommendations.append({
                'type': 'performance',
                'priority': 'medium',
                'message': f'Load time ({avg_load_time:.0f}ms) could be improved',
                'action': 'Consider asset compression and CDN implementation'
            })
        
        # AR success rate analysis
        if ar_success_rate < self.performance_thresholds['ar_success_rate_min']:
            recommendations.append({
                'type': 'compatibility',
                'priority': 'high',
                'message': f'AR success rate ({ar_success_rate:.1%}) below target',
                'action': 'Improve fallback experience, update browser detection'
            })
        
        # Fallback usage analysis
        if fallback_usage > 0.3:  # More than 30% using fallback
            recommendations.append({
                'type': 'compatibility',
                'priority': 'medium',
                'message': f'High fallback usage ({fallback_usage:.1%})',
                'action': 'Consider expanding WebAR browser support'
            })
        
        # Device-specific recommendations
        for device_browser, device_metrics in device_stats.items():
            if len(device_metrics) >= 5:  # Enough data for analysis
                device_ar_rate = sum(1 for m in device_metrics if m['ar_loaded']) / len(device_metrics)
                if device_ar_rate < 0.5:  # Less than 50% success rate
                    recommendations.append({
                        'type': 'device_specific',
                        'priority': 'medium',
                        'message': f'Poor AR performance on {device_browser}',
                        'action': f'Optimize AR experience for {device_browser} specifically'
                    })
        
        # Save recommendations
        recommendation_entry = {
            'timestamp': datetime.now().isoformat(),
            'analysis_period': f'Last {len(recent_metrics)} sessions',
            'metrics_summary': {
                'ar_success_rate': ar_success_rate,
                'avg_load_time_ms': avg_load_time,
                'fallback_usage': fallback_usage
            },
            'recommendations': recommendations
        }
        
        # Store recommendations
        rec_file = "recommendations.json"
        if os.path.exists(rec_file):
            with open(rec_file, "r", encoding='utf-8') as f:
                rec_data = json.load(f)
        else:
            rec_data = []
        
        rec_data.append(recommendation_entry)
        
        # Keep only last 50 recommendation cycles
        if len(rec_data) > 50:
            rec_data = rec_data[-50:]
        
        with open(rec_file, "w", encoding='utf-8') as f:
            json.dump(rec_data, f, indent=2, ensure_ascii=False)

# Initialize feedback system
feedback_system = ResonantFeedbackSystem()

# Rate limiting functionality
def check_rate_limit(client_ip):
    """Simple rate limiting to prevent abuse"""
    try:
        if os.path.exists(RATE_LIMIT_FILE):
            with open(RATE_LIMIT_FILE, "r") as f:
                rate_data = json.load(f)
        else:
            rate_data = {}
        
        # Clean old entries (older than 1 minute)
        current_time = time.time()
        rate_data = {ip: timestamps for ip, timestamps in rate_data.items() 
                    if any(current_time - ts < 60 for ts in timestamps)}
        
        # Check current IP
        ip_requests = rate_data.get(client_ip, [])
        recent_requests = [ts for ts in ip_requests if current_time - ts < 60]
        
        if len(recent_requests) >= MAX_REQUESTS_PER_MINUTE:
            return False
        
        # Add current request
        recent_requests.append(current_time)
        rate_data[client_ip] = recent_requests
        
        # Save updated rate data
        with open(RATE_LIMIT_FILE, "w") as f:
            json.dump(rate_data, f)
        
        return True
    except:
        return True  # Allow request if rate limiting fails

def detect_browser_capabilities(user_agent):
    """Detect browser and WebAR capabilities"""
    user_agent = user_agent.lower()
    
    result = {
        'browser': 'unknown',
        'version': 0,
        'ar_support': False,
        'webxr_support': False,
        'recommendation': 'fallback'
    }
    
    # Browser detection
    if 'chrome' in user_agent:
        result['browser'] = 'chrome'
        # Extract version (simplified)
        try:
            version_part = user_agent.split('chrome/')[1].split('.')[0]
            result['version'] = int(version_part)
        except:
            result['version'] = 0
    elif 'safari' in user_agent and 'chrome' not in user_agent:
        result['browser'] = 'safari'
        try:
            version_part = user_agent.split('version/')[1].split('.')[0]
            result['version'] = int(version_part)
        except:
            result['version'] = 0
    elif 'firefox' in user_agent:
        result['browser'] = 'firefox'
        try:
            version_part = user_agent.split('firefox/')[1].split('.')[0]
            result['version'] = int(version_part)
        except:
            result['version'] = 0
    elif 'edge' in user_agent:
        result['browser'] = 'edge'
        try:
            version_part = user_agent.split('edge/')[1].split('.')[0]
            result['version'] = int(version_part)
        except:
            result['version'] = 0
    
    # Check AR support
    browser_info = SUPPORTED_BROWSERS.get(result['browser'], {})
    if (result['version'] >= browser_info.get('min_version', 999) and 
        browser_info.get('ar_support', False)):
        result['ar_support'] = True
        result['webxr_support'] = True
        result['recommendation'] = 'webxr'
    
    # iOS specific checks
    if 'iphone' in user_agent or 'ipad' in user_agent:
        if result['browser'] == 'safari' and result['version'] >= 11:
            result['ar_support'] = True
            result['recommendation'] = 'arkit'
    
    return result

# HTML Template for WebAR Landing Page
LANDING_PAGE_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuantumHippie AR Pompeii Experience</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            text-align: center;
        }
        .ar-status {
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: bold;
        }
        .ar-supported { background: #4CAF50; }
        .ar-fallback { background: #FF9800; }
        .ar-unsupported { background: #F44336; }
        .start-button {
            background: #00BCD4;
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 25px;
            cursor: pointer;
            margin: 20px;
            box-shadow: 0 4px 15px rgba(0, 188, 212, 0.3);
            transition: all 0.3s ease;
        }
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 188, 212, 0.4);
        }
        .start-button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        .metrics-info {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 20px;
        }
        .loading {
            display: none;
            margin: 20px 0;
        }
        .fallback-content {
            display: none;
            background: rgba(255, 255, 255, 0.1);
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
        }
        #ar-scene {
            display: none;
            width: 100%;
            height: 400px;
            border-radius: 10px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèõÔ∏è‚öõÔ∏è QuantumHippie AR Pompeii</h1>
        <p>Experience ancient Pompeii through quantum-powered augmented reality</p>
        
        <div id="ar-status" class="ar-status">
            üîç Detecting your device capabilities...
        </div>
        
        <button id="start-button" class="start-button" onclick="startARExperience()" disabled>
            üöÄ Start AR Experience
        </button>
        
        <div id="loading" class="loading">
            <p>üåÄ Loading AR assets...</p>
        </div>
        
        <div id="ar-scene"></div>
        
        <div id="fallback-content" class="fallback-content">
            <h3>üì± WebAR not supported</h3>
            <p>Your device doesn't support WebAR, but you can still explore Pompeii:</p>
            <ul>
                <li>üñºÔ∏è Interactive 360¬∞ photos</li>
                <li>üéµ Historical audio experience</li>
                <li>üìö Educational content</li>
            </ul>
            <button class="start-button" onclick="startFallbackExperience()">
                üìñ Explore Without AR
            </button>
        </div>
        
        <div class="metrics-info">
            <p>üîí Privacy-focused experience tracking enabled</p>
        </div>
    </div>

    <script>
        let startTime = performance.now();
        let browserCapabilities = {};
        let sessionStarted = false;
        
        // Device and browser detection
        function detectCapabilities() {
            const userAgent = navigator.userAgent;
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            browserCapabilities = {
                device: /iPhone|iPad|iPod/.test(userAgent) ? 'iOS' : 
                        /Android/.test(userAgent) ? 'Android' : 'Desktop',
                browser: getBrowserName(userAgent),
                user_agent: userAgent,
                screen_resolution: screen.width + 'x' + screen.height,
                webgl_support: !!gl,
                webxr_support: 'xr' in navigator,
                ar_support: false
            };
            
            // Check for WebXR AR support
            if ('xr' in navigator && navigator.xr) {
                navigator.xr.isSessionSupported('immersive-ar').then(function(supported) {
                    browserCapabilities.ar_support = supported;
                    updateARStatus(supported);
                }).catch(function() {
                    browserCapabilities.ar_support = false;
                    updateARStatus(false);
                });
            } else {
                updateARStatus(false);
            }
        }
        
        function getBrowserName(userAgent) {
            if (userAgent.indexOf('Chrome') > -1) return 'Chrome';
            if (userAgent.indexOf('Safari') > -1 && userAgent.indexOf('Chrome') === -1) return 'Safari';
            if (userAgent.indexOf('Firefox') > -1) return 'Firefox';
            if (userAgent.indexOf('Edge') > -1) return 'Edge';
            return 'Unknown';
        }
        
        function updateARStatus(arSupported) {
            const statusEl = document.getElementById('ar-status');
            const startBtn = document.getElementById('start-button');
            const fallbackEl = document.getElementById('fallback-content');
            
            if (arSupported) {
                statusEl.className = 'ar-status ar-supported';
                statusEl.innerHTML = '‚úÖ WebAR Supported! Ready for immersive experience';
                startBtn.disabled = false;
                startBtn.innerHTML = 'üöÄ Start AR Experience';
                browserCapabilities.ar_loaded = true;
                browserCapabilities.fallback_used = false;
            } else {
                statusEl.className = 'ar-status ar-fallback';
                statusEl.innerHTML = 'üì± WebAR not supported, fallback mode available';
                startBtn.disabled = false;
                startBtn.innerHTML = 'üìñ Start Alternative Experience';
                fallbackEl.style.display = 'block';
                browserCapabilities.ar_loaded = false;
                browserCapabilities.fallback_used = true;
            }
        }
        
        function startARExperience() {
            if (sessionStarted) return;
            sessionStarted = true;
            
            const loadingEl = document.getElementById('loading');
            const sceneEl = document.getElementById('ar-scene');
            
            loadingEl.style.display = 'block';
            
            // Simulate AR scene loading
            setTimeout(function() {
                loadingEl.style.display = 'none';
                
                if (browserCapabilities.ar_support) {
                    // Real AR would initialize here
                    sceneEl.innerHTML = `
                        <div style="background: rgba(139, 69, 19, 0.8); padding: 20px; border-radius: 10px;">
                            <h3>üèõÔ∏è AR Scene Active</h3>
                            <p>üëÅÔ∏è Visual: Ancient Roman forum bustling with activity</p>
                            <p>üîä Audio: Sounds of merchants and Roman conversations</p>
                            <p>üëÉ Scent: Olive oil and fresh bread (if supported)</p>
                            <p>‚öõÔ∏è Quantum State: |01‚ü© - Villa dei Misteri scene</p>
                            <button onclick="changeScene()" style="margin-top: 10px; padding: 10px; border-radius: 5px; border: none; background: #4CAF50; color: white;">
                                üîÑ Generate New Quantum Scene
                            </button>
                        </div>
                    `;
                    sceneEl.style.display = 'block';
                } else {
                    startFallbackExperience();
                }
                
                // Track session metrics
                trackMetrics();
            }, 2000);
        }
        
        function startFallbackExperience() {
            const sceneEl = document.getElementById('ar-scene');
            sceneEl.innerHTML = `
                <div style="background: rgba(255, 152, 0, 0.8); padding: 20px; border-radius: 10px;">
                    <h3>üìö Fallback Experience</h3>
                    <p>üñºÔ∏è Viewing 360¬∞ panorama of Pompeii Forum</p>
                    <p>üéµ Playing ambient Roman marketplace sounds</p>
                    <p>üìú Historical context: Daily life in 79 AD</p>
                    <p>üèõÔ∏è Explore Villa of Mysteries frescoes</p>
                    <button onclick="nextFallbackScene()" style="margin-top: 10px; padding: 10px; border-radius: 5px; border: none; background: #FF9800; color: white;">
                        ‚û°Ô∏è Next Historical Scene
                    </button>
                </div>
            `;
            sceneEl.style.display = 'block';
            browserCapabilities.fallback_used = true;
            trackMetrics();
        }
        
        function changeScene() {
            // Simulate quantum scene generation
            const scenes = [
                {state: '00', desc: 'Thermopolium - Street food counter'},
                {state: '01', desc: 'Villa dei Misteri - Dining hall'},
                {state: '10', desc: 'Forum Market - Trading square'},
                {state: '11', desc: 'Private Cubiculum - Bedroom'}
            ];
            const randomScene = scenes[Math.floor(Math.random() * scenes.length)];
            
            document.querySelector('#ar-scene div h3').innerHTML = 
                `üèõÔ∏è AR Scene Active - Quantum State: |${randomScene.state}‚ü©`;
            document.querySelector('#ar-scene div p').innerHTML = 
                `üëÅÔ∏è Visual: ${randomScene.desc}`;
        }
        
        function nextFallbackScene() {
            const scenes = [
                'Amphitheatre gladiator preparation area',
                'Roman bath house (thermae)',
                'Garden peristyle with fountain',
                'Bakery with stone ovens'
            ];
            const randomScene = scenes[Math.floor(Math.random() * scenes.length)];
            document.querySelector('#ar-scene div p').innerHTML = 
                `üñºÔ∏è Viewing: ${randomScene}`;
        }
        
        function trackMetrics() {
            const loadTime = performance.now() - startTime;
            
            const metrics = {
                ...browserCapabilities,
                load_time_ms: Math.round(loadTime),
                ar_session_duration: sessionStarted ? Math.round(performance.now() - startTime) : 0,
                timestamp: new Date().toISOString()
            };
            
            // Send metrics to backend
            fetch('/track', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(metrics)
            }).catch(function(error) {
                console.log('Metrics tracking failed:', error);
            });
        }
        
        // Initialize on page load
        window.addEventListener('load', function() {
            detectCapabilities();
            
            // Track page load metrics after 1 second
            setTimeout(trackMetrics, 1000);
        });
        
        // Track session end
        window.addEventListener('beforeunload', function() {
            if (sessionStarted) {
                trackMetrics();
            }
        });
    </script>
</body>
</html>
"""

# Flask Routes
@app.route('/')
def landing_page():
    """WebAR Landing Page - Entry point from QR code"""
    return render_template_string(LANDING_PAGE_TEMPLATE)

@app.route('/track', methods=['POST'])
def track():
    """
    FIXED: Complete tracking endpoint with proper error handling
    Accepts JSON payload with user metrics and device information
    """
    client_ip = request.environ.get('HTTP_X_REAL_IP', request.remote_addr)
    
    # Rate limiting check
    if not check_rate_limit(client_ip):
        return jsonify({
            'status': 'error', 
            'message': 'Rate limit exceeded'
        }), 429
    
    try:
        if not request.json:
            return jsonify({
                'status': 'error',
                'message': 'No JSON data provided'
            }), 400
        
        payload = request.json
        
        # Add request metadata
        enhanced_payload = payload.copy()
        enhanced_payload.update({
            'client_ip': hashlib.md5(client_ip.encode()).hexdigest()[:8],  # Anonymized IP
            'user_agent': request.headers.get('User-Agent', ''),
            'referer': request.headers.get('Referer', ''),
        })
        
        # Save to feedback system
        success = feedback_system.save_metric(enhanced_payload)
        
        if success:
            return jsonify({
                'status': 'success',
                'message': 'Metrics tracked successfully',
                'resonant_feedback': 'Data processed for experience optimization'
            })
        else:
            return jsonify({
                'status': 'error',
                'message': 'Failed to save metrics'
            }), 500
            
    except Exception as e:
        logger.error(f"Tracking error: {e}")
        return jsonify({
            'status': 'error',
            'message': 'Internal server error'
        }), 500

@app.route('/capabilities')
def check_capabilities():
    """Browser capability detection endpoint"""
    user_agent = request.headers.get('User-Agent', '')
    capabilities = detect_browser_capabilities(user_agent)
    return jsonify(capabilities)

@app.route('/metrics')
def get_metrics():
    """Dashboard endpoint for viewing metrics (admin only)"""
    try:
        if os.path.exists(METRICS_FILE):
            with open(METRICS_FILE, "r", encoding='utf-8') as f:
                metrics = json.load(f)
        else:
            metrics = []
        
        # Calculate basic statistics
        if metrics:
            recent_metrics = metrics[-100:]  # Last 100 sessions
            stats = {
                'total_sessions': len(metrics),
                'recent_sessions': len(recent_metrics),
                'ar_success_rate': sum(1 for m in recent_metrics if m.get('ar_loaded', False)) / len(recent_metrics),
                'avg_load_time': sum(m.get('load_time_ms', 0) for m in recent_metrics) / len(recent_metrics),
                'top_devices': {},
                'top_browsers': {}
            }
            
            # Device/browser statistics
            for metric in recent_metrics:
                device = metric.get('device', 'unknown')
                browser = metric.get('browser', 'unknown')
                stats['top_devices'][device] = stats['top_devices'].get(device, 0) + 1
                stats['top_browsers'][browser] = stats['top_browsers'].get(browser, 0) + 1
        else:
            stats = {'total_sessions': 0, 'message': 'No data available'}
        
        return jsonify({
            'status': 'success',
            'statistics': stats,
            'recent_metrics': metrics[-10:] if metrics else []  # Last 10 for preview
        })
        
    except Exception as e:
        logger.error(f"Metrics retrieval error: {e}")
        return jsonify({
            'status': 'error',
            'message': 'Failed to retrieve metrics'
        }), 500

@app.route('/recommendations')
def get_recommendations():
    """Get QEIT resonant feedback recommendations"""
    try:
        rec_file = "recommendations.json"
        if os.path.exists(rec_file):
            with open(rec_file, "r", encoding='utf-8') as f:
                recommendations = json.load(f)
            return jsonify({
                'status': 'success',
                'latest_recommendations': recommendations[-1] if recommendations else None,
                'recommendation_history': recommendations[-5:] if recommendations else []
            })
        else:
            return jsonify({
                'status': 'success',
                'message': 'No recommendations available yet'
            })
    except Exception as e:
        logger.error(f"Recommendations error: {e}")
        return jsonify({
            'status': 'error',
            'message': 'Failed to retrieve recommendations'
        }), 500

# Health check endpoint
@app.route('/health')
def health_check():
    """System health check"""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now().isoformat(),
        'version': '1.0.0',
        'qeit_principle': 'Resonant Interactive Feedback Active'
    })

if __name__ == '__main__':
    # Create necessary directories and files
    os.makedirs('static', exist_ok=True)
    os.makedirs('templates', exist_ok=True)
    
    print("üåø‚öõÔ∏è WebAR QR Integration Server Starting...")
    print("=" * 50)
    print("üì± Landing Page: http://localhost:5000/")
    print("üìä Metrics Dashboard: http://localhost:5000/metrics")
    print("üí° Recommendations: http://localhost:5000/recommendations")
    print("üè• Health Check: http://localhost:5000/health")
    print("=" * 50)
    
    # Run the Flask application
    app.run(debug=True, host='0.0.0.0', port=5000)
